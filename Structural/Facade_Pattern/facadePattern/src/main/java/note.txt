Facade Pattern 外观模式

实例：
slf4j

外观模式隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。
它向现有的系统添加一个接口，来隐藏系统的复杂性
这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用

介绍
意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之接口
何时使用：1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。
如何解决：客户端不与系统耦合，外观类与系统耦合
关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。
优点：1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性
缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适


外观模式通过引入一个新的外观类（Facade）来充当软件系统中的"服务员"，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互
在外观模式中，那些需要交互的业务类被称为子系统。
若没有外观类，那么每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大；而引入外观类之后，客户类只需要直接与外观类交互，客户类
与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度

外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观
角色打交道，而不需要与子系统内部的很多对象打交道

抽象外观类
在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，
因此可以通过引入抽象外观类来对系统进行改进，在一定程度上可以解决该问题。在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，
对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，
同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的


如何在不修改客户端代码的前提下使用新的外观类呢？解决方法之一是：引入一个抽象外观类，客户端针对抽象外观类编程，而在运行时再确定具体外观类


外观模式效果与适用场景
外观模式是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，
使子系统与客户端的耦合度降低，且客户端调用非常方便。外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。
如绝大多数B/S系统都有一个首页或者导航页面，大部分C/S系统都提供了菜单或者工具栏，在这里，首页和导航页面就是B/S系统的外观角色，
而菜单和工具栏就是C/S系统的外观角色，通过它们用户可以快速访问子系统，降低了系统的复杂程度
所有涉及到与多个业务对象交互的场景都可以考虑使用外观模式进行重构。